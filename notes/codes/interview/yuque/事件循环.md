+ 事件循环是浏览器中用于管理和处理用户交互、网络请求和其他异步操作的机制，确保它们按照顺序和时机得到处理。
+ JS 是**单线程**的，且 JS 的主线程和渲染线程互斥。如果异步操作阻塞 JS 的执行，会造成浏览器的卡死。事件循环为浏览器引入了**任务队列**，使**异步任务可以非阻塞地进行**。
+ 浏览器事件循环在处理异步任务时不会一直等待其返回结果，而是将这个事件挂起，继续执行栈中的其他任务。当异步事件返回结果，将它放到任务队列中，但是不会立即执行回调，要等待当前执行栈中的任务都执行完毕，再取出任务队列中排在第一位的事件，将其对应的回调放到执行栈中执行。



+ JS的执行机制可以看作是一个主线程加上一个任务队列。同步任务放在主线程执行，形成一个执行栈；异步任务有了运行结果会在任务队列放置一个事件；脚本先依次运行执行栈，然后从任务队列里提取事件运行，这个过程是不断重复的，所以又叫做事件循环。
+ 事件模型  [https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF)
    - ![](https://cdn.nlark.com/yuque/0/2022/svg/1622085/1644984975468-93abd212-c246-494f-a6d2-e1314c4e637b.svg)
+ [https://github.com/Troland/how-javascript-works/blob/master/event-loop.md](https://github.com/Troland/how-javascript-works/blob/master/event-loop.md)
    - js引擎包括两个主要组件：
        * <font style="color:rgb(36, 41, 47);">内存堆 － 进行内存分配的区域</font>
        * <font style="color:rgb(36, 41, 47);">调用栈－代码执行时栈帧的位置</font>
    - js引擎运行在宿主环境中，一般指web浏览器或者Node.js
    - 宿主环境含有被称为**事件循环**的内置机制，<font style="color:rgb(36, 41, 47);">事件循环会执行程序中多个代码片段，每次都会调用 JS 引擎</font>
    - <font style="color:rgb(36, 41, 47);">这意味着 JS 引擎只是任意 JS 代码的按需执行环境，</font>**<font style="color:rgb(36, 41, 47);"> LexicalEnvironment (词法环境)和VariableEnvironment（变量环境）</font>**
    - ![](https://cdn.nlark.com/yuque/0/2022/png/1622085/1644985734912-88c07deb-a08b-4767-a9cf-d2424221b31e.png)
    - web API是浏览器的一部分，在其中引入了并发操作，你没有权限访问这些线程，只能调用它们。如果你是Node.js开发，这些是C++APIs
    - <font style="color:rgb(36, 41, 47);">事件循环只有一项简单的工作－监测调用栈和回调队列。如果调用栈是空的，它会从回调队列中取得第一个事件然后入栈，并有效地执行该事件</font>
    - **<font style="color:rgb(36, 41, 47);">ES6事件循环也由JS引擎负责，不再只是包含于宿主环境</font>**<font style="color:rgb(36, 41, 47);">： ES6 规定事件循环如何工作的，这意味着从技术上讲，它在 JS 引擎负责的范围之内，而不再只是扮演着宿主环境的角色。ES6 中 Promise 的出现是导致改变的主要原因之一，因为 ES6 要求有权直接细粒度地调度操作事件循环队列(之后会深入探讨)。</font>
    - <font style="color:rgb(36, 41, 47);">setTimeout(...)并没有自动把回调添加到事件循环队列。它创建了一个定时器。当定时器过期，宿主环境会把回调函数添加到事件循环队列中</font>
+ 宏任务微任务
    - MacroTask（宏任务）：script全部代码、setTimeout、setInterval、setImmediate、I/O、UI Rendering
    - MicroTask（微任务）：Process.nextTick（Node独有）、Promise、Object.observe（废弃）、MutationObserver
+ 作业队列（微任务队列）
    - 作业队列位于事件循环队列（宏任务队列）顶部
    - 作业队列附加于事件循环队列中每个tick末尾。事件循环中微任务一部操作不会在事件循环队列中添加全新事件，而是在当前tick的作业队列末尾添加一个作业项（即在微任务队列中添加微任务）
+ 测试

```plain
console.log('1');

setTimeout(function() {
    console.log('2');
    process.nextTick(function() {
        console.log('3');
    })
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})
process.nextTick(function() {
    console.log('6');
})
new Promise(function(resolve) {
    console.log('7');
    resolve();
}).then(function() {
    console.log('8')
})

setTimeout(function() {
    console.log('9');
    process.nextTick(function() {
        console.log('10');
    })
    new Promise(function(resolve) {
        console.log('11');
        resolve();
    }).then(function() {
        console.log('12')
    })
})

// 1 7 6 8 2 4 3 5 9 11 10 12
```

+ ![](https://cdn.nlark.com/yuque/0/2025/png/1622085/1739431063015-ccffe694-f032-4a35-bd74-59ca34e581f5.png)
+ web worker [https://www.ruanyifeng.com/blog/2018/07/web-worker.html](https://www.ruanyifeng.com/blog/2018/07/web-worker.html)
    - 注意
        * 同源限制：分配给Woker线程运行的脚本文件，必须与主线程脚本文件同源
        * DOM限制：Woker线程全局对象与主线程不同，无法读取主线程所在网页DOM对象，无法使用document，window，parent对象
        * 通信联系：Worker线程和主线程不在同一个上下文环境，不能直接通信，通过消息通信
        * 脚本限制：Worker线程不能执行alert()和confirm()，但可以使用XMLHttpRequest发送AJAX
        * 文件限制：Worker线程不能读取本地文件，加载的脚本必须来自网络
    - 主线程
        * const myWorker = new Worker('worker.js', {name: 'myWorder'})
        * myWorker.postMessage() 向myWorker线程发送消息
        * myWorker.onmessage 指定message 事件的监听函数，发送过来的数据在Event.data属性中
        * myWorker.terminate() 立即终止myWorker线程
    - worker线程
        * self.name
        * self.onmessage
        * self.close() 关闭worker线程
        * self.postMessage() 向产生这个worker的线程发送消息

