## 安全 <font style="color:#DF2A3F;">----done</font>
+ xss
    - 跨站脚本攻击（cross-site scripting）
    - 怎样攻击：通过修改html节点或注入恶意脚本，在浏览器里执行，获取用户cookie、sessionId等，危害数据安全
    - 分类
        * 存储型：攻击者将恶意代码提交到数据库；打开网站时**服务端**将恶意代码从数据库取出，拼接在html 中返回
        * 反射型：攻击者构造特殊 url 包含恶意代码；打开带有恶意代码的 url 时，**服务端**从 url 中取出恶意代码，拼在 html 中返回
        * DOM型：攻击者构造特殊 url 包含恶意代码；用户打开带有恶意代码的 url；**前端 **js 取出 url 中的恶意代码执行
        * 存储型XSS：恶意脚本存储在服务器数据库中
        * 反射型XSS：恶意脚本通过URL参数传递
        * DOM型XSS：通过修改DOM结构执行脚本
    - 怎样防御：html转义；白名单；csp；限制用户输入长度；验证码、密码
+ csrf
    - 跨站请求伪造（cross-site request forgery）
    - 怎样攻击：诱导受害者进入第三方网站，在第三方网站向被攻击网站发送请求，利用受害者在被攻击网站已经获取的凭证，绕过后台验证，冒充受害者对被攻击网站执行操作
    - 是什么：Cookie 往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确 Cookie 的 HTTP 请求，这就是 CSRF 攻击。
    - 怎样防御：攻击特点是第三方网站发起、只能冒用；同源检测、samesite cookei，请求附加信息
        * Samesite：<font style="background-color:#ECAA04;">Set-Cookie: bar=2; Samesite=Lax</font><font style="background-color:#FFFFFF;">  GET请求或 a 标签链接打开，可以带 cookie bar</font>
    - [https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html](https://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html)

## 权限 <font style="color:#DF2A3F;">----1</font>
+ 接口获取权限列表，数组，每个元素是一个权限字段，存入store中 （在导航守卫 router.beforeEach里检查 store 中是否有角色权限列表，没有重新获取并存入）
+ 自定义指令v-permission=['admin', 'xxx']，判断是否有权限，没有的话把绑定自定义指令的dom移除

```javascript
Vue.directive('permission', {
  inserted(el, binding) {
    const { value } = binding
    const roles = store.getters && store.getters.roles
    if (value && value instanceof Array) {
      if (value.length > 0) {
        const permissionRoles = value
        const hasPermission = roles.some(role => {
          return permissionRoles.includes(role)
        })
        if (!hasPermission) {
          el.parentNode && el.parentNode.removeChild(el)
        }
      }
    } else {
      throw new Error(`使用方式： v-permission="['admin','editor']"`)
    }
  }
})

// 复杂 DOM 使用函数 v-if=chekcPer(['admin', 'editor'])
Vue.prototype.checkPer = (value) => {
  if (value && value instanceof Array && value.length > 0) {
    const roles = store.getters && store.getters.roles
    const permissionRoles = value
    return roles.some(role => {
      return permissionRoles.includes(role)
    })
  } else {
    console.error(`need roles! Like v-permission="['admin','editor']"`)
    return false
  }
}
```

+ 对于复杂dom，如表格列表、tab显示，使用v-if=checkPer(['admin'])，定义函数，逻辑与自定义指令一样。
+ 可以将函数作为Vue插件使用
+ Vue.directive
    - 自定义指令作用：**重用涉及普通元素底层 DOM 访问的逻辑**
    - 钩子函数：bind，inserted，componentUpdated，unbind （Vue3的钩子同组件钩子）
    - 钩子函数接收的参数：el，binding(nama、value、oldValue、expression、arg、modifiers)，vnode，oldNode
    - vue3：[https://v3-migration.vuejs.org/zh/breaking-changes/custom-directives.html](https://v3-migration.vuejs.org/zh/breaking-changes/custom-directives.html)
+ Vue.extend
    - <font style="color:rgb(48, 68, 85);">使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</font>
+ Vue.use
    - 插件暴露install方法，参数是Vue构造器、options
    - 全局方法添加到Vue.property

## 表格封装 <font style="color:#DF2A3F;">----4</font>
+ 配置 tableColumn 数组和 tableData 用 props 传入表格组件
+ v-for 遍历 tableColumn 生成表格列，根据业务区分配置，渲染不同的 table-column（展示更多，展示html，两级表头，图片，动态编辑，自定义多选等）
+ 作用域插槽传参，在父组件里自定义模板，通过插槽插入
+ 分页写在表格组件里，emit 传出表格事件和分页事件，分页处理写在 mixin 中混入

```html
<template>
  <el-table>
    <template v-for="item in tableColumn">
      <el-table-column v-if="item.operate" :prop="item.type" :label="item.name" :width="item.width">
        <template slot-scope="scope"> // element 提供
          <slot :name="item.type" :row="scope.row" :column="scope.column"></slot>
        </template>
      </el-table-column>
      <el-table-column v-else :prop="item.type" :label="item.name"></el-table-column>
    </template>
  </el-table>
  <el-pagination></el-pagination>
</template>

// 使用
<template>
	<c-table :tableColumn="tableColumn" :tabelData="tableData">
    <template #myId="{ row }">
      {{ 'ID是' + row.myId }}
    </template>
  </c-table>
</template>
```

## slot插槽 <font style="color:#DF2A3F;">----4</font>
+ 在子组件预留一些位置，由父组件控制这些位置插入的内容
+ 具名插槽
    - 父 <template v-slot:header></template> 或 <template #header></template>
    - 子 <slot name='header'></slot>
+ 作用域插槽
    - 在父组件中访问子组件的数据
    - 父 
        * <template v-slot="{ aaa, bbb }">{{ aaa }}</template>或
        * <template #default="{ aaa, bbb }">{{ bbb }}</template>
    - 子 
        * <slot :aaa="a" :bbb="b" name='default'></slot>
        * name保留，不传

## 项目中icon <font style="color:#DF2A3F;">----15</font>
+ [https://juejin.cn/post/6844903517564436493](https://juejin.cn/post/6844903517564436493)
+ 直接引入图标使用 png svg
+ 阿里图标库 iconfont
    - unicode 引用，当成字体处理，定义@font-face，在 main.js 引入
    - font-class 引用，unicode 变种，语意明确
    - symbol 引用，引入生成的 symbol js，<svg><use <font style="color:rgb(121, 93, 163);background-color:rgb(247, 247, 247);">xlink:href</font><font style="color:rgb(51, 51, 51);background-color:rgb(247, 247, 247);">=</font><font style="color:rgb(223, 80, 0);background-color:rgb(247, 247, 247);">"#icon-xxx"</font>></use><svg>

## 环境变量 <font style="color:#DF2A3F;">----14</font>
+ 接口用 proxy 代理，对不同的前缀配置不同环境的 target，pathRewrite 改写回原 url
+ .env.development 等文件配置不同环境变量，启动、构建时命令加环境参数 --mode ls --dest dist/ls
+ process.env.NODE_ENV === 'development'

```json
"scripts": {
  "serve": "vue-cli-service serve",
  "build": "vue-cli-service build",
  "lint": "vue-cli-service lint",
  "lf": "vue-cli-service serve --mode lf",
  "ls": "vue-cli-service serve --mode ls",
  "roe": "vue-cli-service serve --mode roe",
  "warz": "vue-cli-service serve --mode warz",
  "build:lf": "vue-cli-service build --mode lf --dest dist/lf",
  "build:ls": "vue-cli-service build --mode ls --dest dist/ls",
  "build:roe": "vue-cli-service build --mode roe --dest dist/roe",
  "build:warz": "vue-cli-service build --mode warz --dest dist/warz",
  "build:all": "npm run build:lf && npm run build:ls && npm run build:roe && npm run build:warz"
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/1622085/1715139906720-292f96dd-b026-4167-b0b4-81bd3e45eef4.png)

## 回流、重绘 <font style="color:#DF2A3F;">----13</font>
[https://juejin.cn/post/6844903734951018504](https://juejin.cn/post/6844903734951018504)

[https://web.dev/critical-rendering-path-render-tree-construction/](https://web.dev/critical-rendering-path-render-tree-construction/)



+ 解析渲染过程
    - 解析 HTML 生成 DOM 树
    - 解析 CSS 生成 CSSOM 树
    - 将 DOM 树 和 CSSOM 树组合成一个渲染树
    - 回流/重排（layout/reflow）：回流过程就是计算每个元素的位置和大小，所有相对测量值都转为屏幕上的绝对像素
    - 重绘（paint）：将渲染树的每个可见节点转为屏幕上的实际像素
+ 构建渲染树
    - 从 DOM 树根节点开始遍历每个可见节点
    - 对每个可见节点，从 CSSOM 树中找出对应规则应用
    - 根据每个可见节点及其对应的样式，生成渲染树
+ 不可见节点
    - 不渲染输出的节点，如 script、meta、link等
    - display: none
    - 渲染树只包含可见节点
+ 何时发生回流重绘
    - 页面一开始渲染的时候
    - 添加或删除可见 DOM 元素的时候
    - 元素位置发生变化
    - 元素尺寸发生变化（高度和宽度、边框、内边距、外边距）
    - 浏览器窗口尺寸变化
    - **回流一定会触发重绘，而重绘不一定回流**
+ 浏览器优化机制
    - 每次重排都需要计算消耗，浏览器会将修改放在队列里，批量修改
    - 获取布局信息的时候会强制刷新队列
        * offsetTop、offsetLeft、offsetWidth、offsetHeight
        * scrollTop、scrollLeft、scrollWidth、scrollHeight
        * clientTop、clientLeft、clientWidth、clientHeight
        * getComputedStyle()
        * getBoundingClientRect
+ 减少回流重绘
    - 合并多次对 DOM 和样式的修改（浏览器已优化）
    - 获取的布局信息用变量缓存
    - css3硬件加速（使用太多会占内存）：transform，opacity，filters，Will-change

## 从输入url... <font style="color:#DF2A3F;">----3</font>
+ 输入URL
    - 浏览器判断是否合法 url，不合法当作搜索条件用默认搜索引擎搜索
    - 大部分浏览器会根据历史记录、书签等给出智能提示
+ DNS解析
    - 计算机缓存
        * 查找浏览器缓存、hosts文件配置
        * 查找本地 dns 解析器缓存 ipconfig /displaydns
    - 本地 dns 服务器
        * 查找 TCP/IP 参数中设置的首选 dns 服务器，也就是本地 dns 服务器，要查询的域名是否在<font style="color:rgb(28, 30, 33);">本地配置区域资源（权威）</font>
        * 查找本地 dns 服务器缓存（相当于一个代理的 dns 解析服务器，帮助迭代权威服务器应答，找到最终的 ip 返回）
    - 迭代查询 dns 服务器
        * 本地 dns 服务器发送查询至根 dns 服务器（13台，保存在配置中），应答顶级域 dns 服务器地址 //.com
        * 本地 dns 服务器发送查询至顶级域 dns 服务器，应答权威 dns 服务器地址 // baidu.com
        * 本地 dns 服务器发送查询至权威，应答 ip 地址，返回浏览器，完成解析（迭代，直到找到）// 1.1.1.1
        * 转发器配置：dns 服务器直接的交互查询，如果有设置转发器，可以直接找上一级解析；上一级不能解析，或找根 dns 或转发上上一级，以此循环 [https://blog.csdn.net/wind_cp/article/details/83471841](https://blog.csdn.net/wind_cp/article/details/83471841)
    - 从客户端到本地 dns 服务器的查询是递归查询，而 dns 服务器之间的交互查询是迭代查询
+ 建立TCP连接
+ 发送HTTP请求
+ 服务器响应请求
+ 浏览器解析渲染页面
+ HTTP请求结束，断开TCP连接
    - <font style="color:rgb(28, 30, 33);">现在的页面为了优化请求的耗时，默认都会开启持久连接（Connection: Keep-Alive），那么一个 TCP 连接确切关闭的时机，是这个 tab 标签页关闭的时候。</font>
    - <font style="color:rgb(28, 30, 33);">HTTP/2 中 Connection: Keep-Alive 是被忽略的</font>



+ ![](https://cdn.nlark.com/yuque/0/2023/png/1622085/1681125943782-bf7fb925-9dba-4d41-a1b3-b0daba303c8c.png)

## Iterator <font style="color:#DF2A3F;">----done</font>
+ 原生具备 <font style="color:#DF2A3F;">iterator</font> 接口，即默认部署了 <font style="color:#DF2A3F;">Symbol.iterator</font> 属性
    - Array
    - Map
    - Set
    - arguments
    - DOM NodeList 对象
+ Symbol.iterator 属性是个函数，返回遍历器对象。这个遍历器对象有 next() 方法，返回有 value、done 属性的对象

```javascript
let arr = ['a', 'b', 'b']
let it = arr[Symbol.iterator]()
it.next() // { value: 'a', done: false }
it.next() // { value: 'b', done: false }
it.next() // { value: 'c', done: false }
it.next() // { value: undefined, done: true }
```

+ for...of 循环本质上就是调用 Symbol.iterator 产生的遍历器
    - <font style="color:rgb(36, 41, 47);">for...of</font><font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);"> 循环内部会自动调用迭代器对象的 </font><font style="color:rgb(36, 41, 47);">next</font><font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);"> 方法来获取下一个元素，直到迭代器对象的 </font><font style="color:rgb(36, 41, 47);">done</font><font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);"> 属性为 </font><font style="color:rgb(36, 41, 47);">true</font><font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">，循环才会结束。</font>
+ 类数组：数值作为 key；有 length 属性；如 { 0: 'a', 1: 'b', length: 2 }，没有 iterator 接口，用 Array.form() 将其转为数组，则可以使用 for...of 遍历
+ <font style="color:#DF2A3F;">for...of</font>，扩展运算符（<font style="color:#DF2A3F;">...</font>），<font style="color:#DF2A3F;">解构赋值</font>，<font style="color:#DF2A3F;">Array.form</font> 内部调用的都是遍历器接口

```javascript
// Generator 函数，返回的是遍历器对象
function* numbers () {
  yield 1
  yield 2
  return 3
  yield 4
}

// 扩展运算符
[...numbers()] // [1, 2]

// Array.from 方法
Array.from(numbers()) // [1, 2]

// 解构赋值
let [x, y] = numbers();
x // 1
y // 2

// for...of 循环
for (let n of numbers()) {
  console.log(n)
}
// 1
// 2
```

## forEach 跳出循环 <font style="color:#DF2A3F;">----done</font>
+ return 跳过本轮迭代，相当于for循环或for...of里的continue

```javascript
// 基本示例
[1, 2, 3, 4, 5].forEach(item => {
    if (item === 3) {
        return; // 跳过3这一轮
    }
    console.log(item); // 输出: 1, 2, 4, 5
});

// 实际应用
const array = [1, 2, 3, 4, 5];
array.forEach(item => {
    if (item % 2 === 0) {
        return; // 跳过偶数
    }
    console.log(item); // 输出: 1, 3, 5
});


// 对比其他方法
// for循环
for (let i = 0; i < array.length; i++) {
    if (condition) continue;
    // 逻辑
}

// for...of
for (const item of array) {
    if (condition) continue;
    // 逻辑
}
```

+ try...catch 和 throw new Error() 跳出循环

```javascript
try {
  array.forEach(item => {
    if (condition) {
      throw new Error('break');
    }
    // 其他逻辑
  });
} catch (e) {
  if (e.message !== 'break') throw e;
}
```

## Array api <font style="color:#DF2A3F;">----2</font>
+ push() 返回数组长度
+ pop() 删除最后一个元素，返回该元素的值
+ shift() 删除第一个元素，返回该元素的值
+ unshift() 返回数组长度



+ keys() 返回一个遍历器对象，用来遍历所有的键名
    - **遍历器对象：包含 next() 方法的对象，next() 返回 { value: '1', done: false  } **
    - **可以用 for...of 遍历这个遍历器对象**
+ values() 返回一个遍历器对象，用来遍历所有的键值
+ entries() 返回一个遍历器对象，用来遍历 <font style="color:#DF2A3F;">[键名, 键值]</font> 组成的数组
+ filter() 创建给定数组一部分的浅拷贝，应该返回真值以将结果保留在数组中，否则返回假值
+ forEach() 返回undefined
+ map() 创建新数组返回
+ reduce()
    - reduce(callbackFn, initialValue)
    - 四个参数：previousValue，currentValue，currentIndex，array
+ reduceRight()



+ inclueds()
+ every() 返回布尔值，是否所有元素满足测试函数。第二个参数指定测试函数 this
+ some() 返回布尔值，是否有元素满足测试函数。
+ indexOf() 返回索引值，不存在-1
+ find() 返回第一个满足测试函数的值，不存在返回undefined
+ findIndex() 返回第一个满足测试函数的索引，不存在返回-1
+ findLast()
+ findLastIndex()



+ fill(value, start, end) 改变数组，返回修改后的数组
+ concat() 合并两个或多个数组，返回新数组，不改变原数组
+ at() 接收整数值并返回该索引对应的元素，允许正数和负数
+ join() 默认逗号拼接 - String split() 字符串分割为数组
+ sort()
    - 默认转为字符串，逐个比较字母的 utf-16 编码顺序
    - 指定排序算法 array.sort((a, b) => return a-b)  // <0，a 在 b 前
+ toSorted() 是 sort() 方法的复制版本，返回新数组，不改变原数组
+ reverse() 位置颠倒，会改变原数组
+ toReversed() 是 reverse() 的复制版本，不改变原数组
+ slice(start, end) 包括start，不包括end，返回新数组，不改变原数组
+ splice(start, deleteCount, item1, item2, item3) 返回包含被删除元素的数组，会改变原数组
+ toSpliced() 是 splice() 的复制版本，不改变原数组，返回修改后的新数组
+ flat()
+ flatMap()  相当于 arr.map(...args).flat()



+ Array.from()
+ Array.isArray()



+ 会改变原数组:
    - push()
    - pop()
    - shift()
    - unshift()
    - splice()
    - sort()
    - reverse()
    - fill() - 使用一个固定值填充数组中的元素
    - copyWithin() - 复制数组中的一部分元素到同一数组中的另一个位置

## jwt; 登录流程 <font style="color:#DF2A3F;">---- 9</font>
+ JWT (Json Web Tokens)
    - 原理
        * 服务器认证后，生成JSON对象，加上header、签名，发回给用户
        * 客户端收到JWT，可以存在localStorage里，每次与服务端通信，放在HTTP头信息Authorization里带上（或者Cookie，Post请求数据体里）
        * 服务器用它来认定用户身份
    - Header（头部）.Payload（负载）.Signature（签名）
    - JWT默认不加密；一旦泄露任何人都可以盗用；不仅用于认证，也可以用于交换信息；要用https传输
    - 一旦生成下发，到期之前不能废除，不能更改权限，除非服务器部署额外逻辑
+ 后台登录（项目）
    - 登录页提交用户名密码，登录接口，返回token
    - token存入localStorage
    - router.beforeEach 里从localStorage获取token，是否有，没有跳转登录页
    - axios请求拦截里，请求头加上Authorization
    - axios响应拦截里判断状态码，是否token失效，失效跳转登录页
+ 登录（项目）
    - url里获取参数，分别存入localStorage
    - router.beforeEach
        * localStorage里获取token，是否有
        * 有进入路由；没有从localStorage里获取参数，调用登录
        * 登录返回的token存入localStorage
        * 把token设为请求头 Authorization "Bearer" + token
    - 如果调用接口时token失效，自动重新登录，跳转首页（后台跳转登录页，手动登录）
+ session\cookie用户认证流程
    - 用户向服务器发送用户名、密码
    - 服务器验证通过后，在当前会话（session）里保存相关数据，如用户角色、登录时间等
    - 服务器向用户返回一个session_id，写入用户的Cookie
    - 用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器
    - 服务器收到 session_id，找到前期保存的数据，获取用户身份
    - 问题
        * 服务器集群需要共享session；数据持久化，写入数据库，工程量大

## for in; for of <font style="color:#DF2A3F;">----8</font>
+ for in
    - 遍历对象及其原型链上的可枚举属性，返回key，不会遍历 Symbol 属性
    - 如果遍历数组，除了**索引**，还返回数组对象的**自定义属性**及其**原型链上的可枚举属性**
+ Object.keys()
    - 返回对象自身可枚举属性组成的数组
    - 不会遍历原型链上的属性和Symbol属性
+ for of
    - 支持遍历数组，类数组对象，字符串，Map对象，Set对象
    - 不支持遍历普通对象
    - 返回数组元素的**值**

## js模块化 <font style="color:#DF2A3F;">----5</font>
+ es modules
    - 官方模块化规范，现代浏览器原生支持，import加载模块，export导出
    - Node.js同步加载，浏览器异步加载
    - 编译阶段执行，静态执行（不能用变量、表达式），支持静态分析，import\export只能在模块顶层
    - 输出的是值的引用
    - import 写法；引入文件直接执行
    - import() 函数，运行时加载，异步加载；require是同步加载
        * 返回promise，推荐使用await 
+ CommonJs 
    - exports导出，require同步加载模块，首次加载会缓存，后续加载读缓存
    - 主要在服务端（如 Node.js）使用，也可以通过打包工具打包后在浏览器端使用
    - 输出的是值的拷贝，对引用类型，值是引用
    - 运行阶段执行
    - 缺点：同步加载不适用于浏览器；浏览器使用需要打包；难以支持模块静态分析
+ CommonJs、ESM区别
    - 运行时加载/编译时输出接口-是否支持静态分析（静态分析支持tree-shaking）
    - 值的拷贝/值的引用
    - 同步/异步 Node.js/浏览器

## Vue.extend <font style="color:#DF2A3F;">----done</font>
+ 用于创建一个基于 Vue 构造函数的“子类”，参数应为一个包含组件选项的对象
+ 创建一个可复用的组件构造器，可以用它动态创建新组件

```javascript
// 创建构造器
const Profile = Vue.extend({
  template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',
  data() {
    return {
      firstName: 'Walter',
      lastName: 'White',
      alias: 'Heisenberg'
    }
  }
})
// 创建一个 Profile 的实例，并将它挂载到一个元素上
new Profile().$mount('#mount-point')

// 创建实例时可以用 propsData 向组件内 props 传参
new Profile({ propsData: { prop1: 'value1', prop2: 'value2' } })
```

+ toast 实现
    - this.$toast(message, { position: 'top' })
    - 把 $toast 方法挂在 Vue.prototype 上就能这样调用，写插件（install，Vue.use()）
    - $toast 方法里动态创建 toast 组件，用写好的 Vue.extend 组件构造器
    - 创建子类实例时传入的参数在组件内 props 里接收
    - 挂载后把 $el 插入到 body 里

## sentry/飞书日志
+ 搭建好sentry后台，提供dsn（data source name），前端根据文档接入
+ 传入app和router，可以集成router，自定义报错参数
+ 飞书群日志推送，提供hook，调用hook，axios响应拦截里调用，实质上就是http请求

## 全局修改ui库样式
+ 自定义ui组件样式，覆盖原ui库样式
+ main.js 引入自定义样式

## 微信小程序
+ 结构

```javascript
|- app.json // 用于整个项目的配置，对所有页面都有效 { "pages": ["pages/home/home"] }
|- app.js  // App({}) 初始化小程序实例
|- app.wxss
|- pages
   |- home
      |- home.wxml
      |- home.js // Page({}) 初始化页面实例
```

+ 生命周期
    - app [https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#%E5%8F%82%E6%95%B0](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#%E5%8F%82%E6%95%B0)
    - page [https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onLoad-Object-query](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onLoad-Object-query)
    - onLaunch() <font style="color:rgb(34, 34, 34);">小程序初始化完成时触发，全局只触发一次</font>
    - <font style="color:rgb(34, 34, 34);">onLoad()，onShow()，onReady()，onHide()，onUnload()</font>

![](https://cdn.nlark.com/yuque/0/2023/png/1622085/1687753783121-523d57d2-f573-49fc-b2e2-452357170e0a.png)

+ 数据
    - 全局数据 globalData，const app = getApp(); app.globalData.xx
    - 页面数据 data
    - this.setData({ name: '张三' }) this指向页面实例
    - <font style="color:#DF2A3F;">wx</font> 是小程序提供的原生对象，所有客户端 api 都定义在它上面
        * wx.showToast({ title: '提示', duration: 1000 })，
        * wx.showModal()
    - api
        * wx:for={{ items }}
        * wx.setStorageSync('items', itemArr); wx.getStorageSync() 客户端存储，同步
        * wx.getSetting() 是否获得授权 wx.getUserInfo() 获取用户信息
        * 跳转页面
            + <navigator url="../home/home">首页</navigator>
            + wx.navigateTo({ url: '../home/home' }) 保留当前页跳转
            + wx.redirectTo() 关闭当前页跳转新页面
+ 事件
    - tap
    - touchstart
    - touchmove
    - touchend
    - touchcancel
    - longpress

## 浏览器内核 ----18
Trident（或称为 MSHTML）：这是微软开发的浏览器核心，用于 Internet Explorer 浏览器。不过，自从微软推出 Edge 浏览器后，Trident 已经不再维护和更新。



Gecko：这是 Mozilla 基金会开发的浏览器核心，用于 Firefox 浏览器。Gecko 具有强大的扩展性和高级的 Web 标准支持。



WebKit：这是苹果公司开发的浏览器核心，最早用于 Safari 浏览器。WebKit 非常注重速度和性能，并且在移动设备上得到广泛应用。



Blink：这是 Google 开发的浏览器核心，最早用于 Chrome 浏览器。Blink 实际上是 WebKit 的一个分支，主要用于提升浏览器的渲染速度和稳定性。目前，几乎所有基于 Chromium 内核的浏览器都采用了 Blink。



Presto：这是挪威公司 Opera Software 开发的浏览器核心，用于 Opera 浏览器。然而，自从 Opera 决定转向使用 Blink 内核后，Presto 已经停止维护。

## 函数式 <font style="color:#DF2A3F;">----17</font>
[https://www.yuque.com/u1361107/xe1aqa/br64aor0kxybhson](https://www.yuque.com/u1361107/xe1aqa/br64aor0kxybhson)

+ 函数组合：如果一个值要经过多个函数才能变成另外一个值，就可以把所有中间步骤合成一个函数
+ 柯里化：把一个多参数的函数，转化为单参数的函数
+ 纯函数：输出仅由输入决定，不产生副作用。不依赖外部数据，不改变外部状态
+ 副作用：如果一个函数或表达式除了返回一个值外，还与外部可变状态进行了交互，则它是有副作用的（调用函数的时候会对外部产生影响，例如改变了全局变量）
+ 幂等：如果一个函数多次执行返回相同结果，则它是幂等的

## async await <font style="color:#DF2A3F;">----7</font>
+ async函数返回Promise对象。async 函数可以看作是多个异步操作，合并成一个 Promise 对象
    - async 里返回不是 promise 的值，也会被包装在一个 promise 中
+ await 命令后面等待的基于 promise 的异步操作被兑现或拒绝后才会恢复进程，**promise 的解决值会被当做 await 表达式的返回值。拒绝后中断进程**
+ await命令后面，可以是 Promise对象和原始类型的值（数值、字符串、布尔值，会自动转成立即 resolved　的 Promise 对象）
+ 错误处理
    - 如果 await 后面的异步操作出错，那么等同于 async 函数返回的 Promise 对象被 reject
    - 方法1：可以把 await 放在 try...catch 结构里
    - 方法2：await 后面的 Promise 对象再跟一个 catch 方法

```javascript
async function myFunction() {
  try {
    await somethingThatReturnsAPromise();
  } catch (err) {
    console.log(err);
  }
}

// 另一种写法

async function myFunction() {
  await somethingThatReturnsAPromise()
    .catch(function (err) {
      console.log(err);
    });
}
```

+ 多个 await 不存在继发关系的话，最好同时触发

```javascript
// 写法一
let [foo, bar] = await Promise.all([getFoo(), getBar()]);

// 写法二
let fooPromise = getFoo();
let barPromise = getBar();
let foo = await fooPromise;
let bar = await barPromise;
```

+ 可以用 await 实现休眠效果

```javascript
function sleep(interval) {
	return new Promise(resolve => {
  	setTimeout(resolve, interval)
	})
}

// 用法
async function one2FiveInAsync() {
  for (let i = 1; i <= 5; i++) {
    console.log(i)
    await sleep(1000)
  }
}
```

async函数好处/和Promise关系：

async函数是基于Promise的，它返回Promise对象，await后面也是跟的Promise对象，可以理解为把多个异步操作合并为一个Promise对象。好处就是代码更简洁易读，把异步代码的像同步代码。

## return continue break <font style="color:#DF2A3F;">----6</font>
+ break
    - 跳出最内层循环，或退出一个switch语句
+ continue
    - 跳过本轮循环，继续下一轮迭代
    - 用在while、do/while、for、for/in语句的循环体内
+ return
    - 指定函数的返回值，只能用在函数体内

## map,set,symbol,bigint <font style="color:#DF2A3F;">----16</font>
+ Map
    - Map 对象保存键值对，任何值（对象或基本类型）都可以作为键。Object 的 键必须是 String 或 Symbol
    - 能够记住键的插入顺序
    - set()；get()；has()；size()；clear()；delete()
    - keys()；values()；entries()；forEach()
    - keys()、values()、entries() 返回遍历器对象，有 next() 方法，可以用 for...of... 遍历
+ Set
    - Set 对象存储任何类型的唯一值，Set 中的元素只会出现一次
    - add()；has()；size()；delete()；clear()
    - keys()===values()；entries()；forEach()
    - 数组去重：[...new Set(arr)] / Array.from(new Set(arr))
+ Symbol
    - 每个从 Symbol() 返回的 symbol 值都是唯一的，symbol 是一种基本数据类型
    - 可以作为对象属性的标识符（key）
    - let sym1 = Symbol()  不能用 new 运算符
+ BigInt
    - BigInt 是一种内置对象，提供方法表示大于 2^53 - 1 的正数
    - 用法：整数字面量后面加 n；或者调用函数 BigInt() 传递整数值或字符串值

## js单线程 <font style="color:#DF2A3F;">----19</font>
+ js 为什么是单线程的
    - js 最初就是为了在浏览器中执行脚本设计的
    - 需要处理用户操作、dom 树、css 样式树，多线程操作可能出现 ui dom 冲突
    - 单线程可以简化并发问题，开发人员不需要考虑线程间的同步和锁
+ 单线程缺点
    - 阻塞： js 在执行某个任务时会阻塞线程，如果耗时大会导致页面响应变慢、卡顿
    - cpu：难以利用多核 cpu，对 cpu 密集型任务（如图像处理、视频编码）执行效率低
    - 无法实现真正的并行：js 通过事件循环机制实现异步编程，事件循环核心是一个事件队列，存储需要执行的任务，js 引擎依次取出任务执行。这种方式需要使用回调、promise、async/await 等技术，复杂度，容易回调地狱
+ Web Worker
    - 一定程度上解决 js 单线程的缺点
    - 主线程
        * 创建 worker 线程：const worker = new Worker('work.js')
        * 发送消息：worker.postMessage('hi')
        * 接收消息：worker.onmessage = function (event) { console.log(event.data) }
        * 关闭：worker.terminate()
    - Worker 线程
        * 接收消息：self.onmessage = function (event) { console.log(event.data) }
        * 发送消息：self.postMessage()
        * 在 Worker 内部关闭自身：self.close()

## 前端上传下载 <font style="color:#DF2A3F;">----20</font>
+ 上传
    - 浏览器不能直接操作文件系统，暴露出接口，由用户授权发起访问文件动作，读取文件内容进内存，再发起请求给服务端
    - 使用 form 表单：input type="file" 表单编码格式 multipart/form-data

```html
<form action="http://localhost:8080/upload" method="post" enctype="multipart/form-data">
  <input type="file" name="file" id="mfile3">
  <button type="submit">上传</button>
</form>
```

    - 使用 FormData：form = new FormData(); form.append('file', file) 浏览器提供的 FormData 构造函数，编码格式 multipart/form-data
    - 大文件上传 [https://juejin.cn/post/6844903860327186445](https://juejin.cn/post/6844903860327186445)
        * 切片上传
        * File 对象是 Blob 对象的子类，Blob 对象由一个重要的方法 slice，可以对二进制文件拆分
        * 每个切片上加参数，识别切片顺序，识别切片来自同一个文件
        * 断点续传：从已上传部分继续上传未完成部分。保存已上传信息，下次传输相同文件时，遍历切片列表，只选择未上传的切片进行上传（可以保存在服务端或客户端 localStorage）
        * 上传进度和暂停：xhr.progress 监控每一个切片上传进度；xhr.abort 取消请求，取消当前未完成上传切片的上传，恢复时和断点续传类似，重新发送未上传的切片
+ 下载
    - [文件下载.pdf](https://www.yuque.com/attachments/yuque/0/2023/pdf/1622085/1697019047342-aab5ec3b-7d9e-4323-9783-78a945f7da5c.pdf)
    - 后端返回文件流
        * Content-Disposition: inline/attachment 响应头，在页面中内联展示/下载
        * 浏览器无法识别的类型，直接下载
    - 后端返回静态地址
        * 动态创建 a 标签，下载
        * 非同源，使用 blob:url/data:url，URL.createObjectURL()，转为 blob 对象
            + a 标签 `download` 只有在`同源URL`或 `blob:` 、`data: `协议起作用
            + 非同源的链接，用 axios 请求下载转为 blob 对象，再用 `URL.createObjectURL()` 转为 `blob:url`，将 blob:url 作为 a 标签的 href
            + 参考
                - a：[https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a)
                - blob：[https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL](https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL)
                - data：[https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URIs](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URIs)

```javascript
cosnt url = 'http://localhost:8888/api/downloadUrl';
axios({
  method: 'get',
  url,
  responseType: 'blob'
}).then(res => {
  const blob = res.data;
  const filename = url.split('/').pop();
  const aTag = document.createElement('a');
  aTag.download = filename;
  const blobUrl = URL.createObjectURL(blob);
  aTag.href = blobUrl;
  aTag.click();
  URL.revokeObjectURL(blob);
}) 
```

        * 大文件分片下载：Range 请求头



## 数组转树 <font style="color:#DF2A3F;">----done</font>
+ 从根节点出发，每一轮迭代找到pid为当前节点id的节点，作为当前节点的children，递归进行

```javascript
const list = [
  { pid: null, id: 1, data: "1" },
  { pid: 1, id: 2, data: "2-1" },
  { pid: 1, id: 3, data: "2-2" },
  { pid: 2, id: 4, data: "3-1" },
  { pid: 3, id: 5, data: "3-2" },
  { pid: 4, id: 6, data: "4-1" }
]

function listToTree (list, id = null) {
  return list.reduce((result, item) => {
    // 如果元素的pid等于本轮迭代的id，也就是元素为本轮迭代节点的子节点，
    把他放进result里（并递归寻找children）；否则直接返回result
    // reduce 里 result 是上一次调用 reducer 函数的返回值
    if (item.pid === id) {
      item.children = listToTree(list, item.id)
      return [...result, item]
    }
    return result
  }, [])
}

function listToTree(list) {
  const roots = []
  const map = new Map()

  // 初始化所有节点为 key-value 对
  list.forEach(item => {
    map.set(item.id, { ...item, children: [] })
  })
  
  list.forEach(item => {
    const parent = map.get(item.pid)
    const node = map.get(item.id)
    // 如果有父节点，则加入父节点的子节点中
    if (parent) {
      parent.children.push(node)
    } else {
      // 如果没有父节点，则为根节点
      roots.push(node)
    }
  })
  return roots
}

const tree = listToTree(list)
console.log(tree)
```

## 树转数组
从最高层开始遍历，判断节点是否有children，没有直接加入数组，有的话对其children执行转数组方法，将其结果解构进最终数组。

```javascript
let tree = [
  {
    "pid": null,
    "id": 1,
    "data": "1",
    "children": [
      {
        "pid": 1,
        "id": 2,
        "data": "2-1",
        "children": [
          {
            "pid": 2,
            "id": 4,
            "data": "3-1",
            "children": [
              {
                "pid": 4,
                "id": 6,
                "data": "4-1",
                "children": []
              }
            ]
          }
        ]
      },
      {
        "pid": 1,
        "id": 3,
        "data": "2-2",
        "children": [
          {
            "pid": 3,
            "id": 5,
            "data": "3-2",
            "children": []
          }
        ]
      }
    ]
  }
]

// 2
function treeTolist(tree) {
  return tree.reduce((result, item) => {
    let { pid, id, data } = item
    
    let cur = { pid, id, data }

    if (item.children) {
        return [...result, cur, ...treeTolist(item.children)]
    }
    return [...result, cur]
  }, [])
}

// 1
function treeTolist(tree) {
  return tree.reduce((result, item) => {
    let { pid, id, data } = item

    let cur = { pid, id, data }
    return result.concat([cur], (item.children && item.children.length) ? treeTolist(item.children) : [])
  }, [])
}

let list = treeTolist(tree)
console.log(list, 'list')
```

## shadow Dom <font style="color:#DF2A3F;">----21</font>
+ 将一个隐藏的、独立的 DOM 附加到一个常规 Dom 节点上
+ 例如 <video> ，能看到的只是一个 video 标签，实际上它的 shadow Dom 中包含一系列的按钮、控制器

## 前端性能优化 <font style="color:#DF2A3F;">----done</font>
+ 大纲
    - DNS，TCP
    - HTTP2，HTTP缓存，CDN缓存
    - 解析 vue 骨架屏
    - Gizp 压缩文件，图片压缩
    - KeepAlive，列表骨架屏，图片超视口不显示，接口合并，路由懒加载
+ 新大纲
    - gzip，图片压缩
    - keepalive，骨架屏，接口合并，路由懒加载，图片隐藏
    - http缓存，http2，链路（DNS，TCP，CDN）
+ 减少白屏时间
    - DNS 解析优化，TCP 连接优化（运维加缓存， Native webview 预热）
    - 请求优化：使用 HTTP/2 协议，依赖多路复用、首部压缩、二进制分帧等特性加快响应速度
    - 页面渲染优化：骨架屏
    - 资源加载优化
        * **Gzip** 压缩文件 vite-plugin-compression 生成 .gz 文件
        * JS 文件拆分，动态加载
        * 资源上传 **CDN**，**HTTP 缓存**
        * **HTTP/2**
    - 接口请求优化：接口合并
    - Native 相关优化
        * webview 容器预热，减少 webview 初始化时间
        * DNS 优化，App 在打开后与解析网页需要的域名
        * 资源预加载，App 提前加载网页资源到本地
+ 业务
    - **KeepAlive** 组件缓存组件，避免重复请求和渲染
    - 列表骨架屏
    - 上传**图片压缩**
    - 图片超出视口后不显示，内存 **useElementVisibility**
+ 多图站点性能优化
    - 图片优化
        * 选择合适的图片格式 jpeg，png，webp，svg
        * 图片压缩
    - 网络传输优化
        * HTTP/2 多路复用解决浏览器有同源最大并发连接数限制
        * CDN 缓存
    - 加载策略优化
        * 懒加载 loading=lazy
        * 预加载
        * 响应式图片加载：不同媒体条件加载不同图片；提供图片格式回退方案

## axios封装 <font style="color:#DF2A3F;">----done</font>
+ 创建 axios 实例，添加请求拦截和响应拦截。（请求头加 token、判断状态码统一处理错误）
+ 给 axios 实例加一层函数，参数接收 axios 选项，并添加全局公用参数
+ 给不同的请求方法创建 async 函数，返回结果（async 函数返回值为 Promise）
+ 直接调用各请求方法对应函数；或创建公用 methoeGet、methodPost，使用时只需传入 url 和 参数

```javascript
// service.js 创建 axios 实例，添加请求响应拦截
const service = axios.create({
  baseURL: ''
})
service.interceptors.request.use(
  config => {
    ...
    return config
  },
  err => {
    return Promise.reject(err)
  }
)
service.interceptors.response.use(
  response => {
    return response.data
  },
  err => {
    return Promise.reject(err)
  }
)
export default service
```

```javascript
// useAxios.js 声明不同的 Method 方法
import service from './service'
const requese = (option) => {
  const { url, method, params, data } = option
  const staticParams = {} // 公用参数，如 uid 等
  return service({
    url,
    method,
    params: Object.assign(params || {}, staticParams),
    data: Object.assign(data || {}, staticParams)
  })
}
async function getFn (option) {
  const res = await request({
    method: 'GET',
    ...option
  })
  return res
}
async function postFn (option) {
  const res = await request({
    method: 'POST',
    ...option,
  })
  return res
}
async function deleteFn (option) {
  const res = await request({
    method: 'DELETE',
    ...option
  })
  return res
}
async function putFn (option) {
  const res = await request({
    method: 'PUT',
    ...option
  })
  return res
}

export const useAxios = () => {
  return {
    get: getFn,
    post: postFn,
    delete: deleteFn,
    put: putFn
  }
}
```

```javascript
// common.js 通用请求 api
import { useAxios } from './useAxios.js'
const request = useAxios()

export const function methodGet (url, params) {
  return request.get({ url, params })
}
export const function methodPost (url, data) {
  return request.post({ url, data })
}
export const function methodDelete (url, data) {
  return request.delete({ url, data })
}
export const function methodPut (url, data) {
  return request.put({ url, data })
}
```

```javascript
// 在组件中引入需要的请求方法使用
import { methodGet, methodPost } from '@/src/axios/common.js'

methodGet('api/xxx', {}).then(res => {
  console.log(res)
})

methodPost('api/xxx', {}).then(res => {
  console.log(res)
})
```

## 移动端适配 <font style="color:#DF2A3F;">----10</font>
+ pc 端概念
    - screen.height/screen.width 屏幕尺寸，设备的 pixels, 是显示器的特征，用不到
    - Element.getBoundingClientRect().width 获取到的是物理像素
    - <font style="color:#DF2A3F;">window.innerWidth/window.innerHeight</font>
        * 浏览器可视区域，包含滚动条
        * 度量：css 的 pixels
        * 窗口内部宽度使用 css 的 pixels，会随着放大浏览器而减少
        * 放大时1px css 占的设备像素变大，所以同样的区域内 css 像素减少
    - window.pageXOffset/window.pageYOffset  
        * <font style="background-color:#FBDE28;">（已废弃，用 scrollX/Y替代） 在window上</font>
            + <font style="background-color:#FBDE28;">scrollWidth/Height 滚动后包含视口外全部页面的宽高（在document.documentElement上，可写）</font>
            + <font style="background-color:#FBDE28;">scorllTop/Left 偏移距离</font>
        * 定义了页面（document）的相对于窗口原点的水平、垂直位移
        * 度量：css 的 pixels
        * 放大浏览器时，浏览器会保存用户当前可见的页面元素依然在可见位置，所以 window.pageX/YOffset 并没有改变
    - 视窗 viewport
        * 控制网站的最高块状容器：<html>元素
        * 一个块级元素宽度为父元素的100%，<body>的宽度就是其父元素<html>的宽度，<html>元素为 viewport 宽度的 100%
        * 页面放大，溢出 <html> ，但宽度 100% 的元素仍是viewport 的宽度，不会占满放大后的整个页面
    - <font style="color:#DF2A3F;">document.documentElement.clientWidth/Height</font>
        * document.documentElement 即 <html> 元素
        * 度量：css 的 pixels
        * 获取到的依然是 viewport 的尺寸，给 <html> 设置宽度不会影响这个取值
        * 和 window.innerWidth/Height 相比，没有包含滚动条
    - document.documentElement.offsetWidth/Height
        * <html> 本身的宽高，给 <html> 设置宽度将反映在 offsetWidth
        * 度量：css 的 pixels
    - 事件坐标
        * pageX/Y 以 css 像素为单位提供相对于 <html> 元素的坐标
        * clientX/Y 以 css 像素为单位提供相对于 viewport 视口的坐标
        * screenX/Y 以 css 像素为单位提供相对于屏幕的坐标（多屏会从最边缘的屏幕开始算
+ 移动端
    - viewport 有两个
        * visual viewport 视觉视口，可以看到的部分，window.innerWidth/innerHeight 获取，但是支持不佳
        * layout viewport 布局视口，页面真正宽高，有超出视口部分看不到，document.documentElement.clientWidth/clientHeight 获取
    - window.pageX/YOffset 视觉视口相对于布局视口的当前位置
    - document.documentElement.offsetWidth/Height 以 css 像素为单位提供 <html> 元素的宽高，同 pc
    - 媒体查询 width/height 参照布局视口计算
    - <meta name="viewport" content="width=320"> 设置布局视口宽度
+ 设备像素比 dpr
    - window.devicePixelRatio 获取当前设备 dpr
    - 设备像素比 = 物理像素 / 设备独立像素（css 像素）
    - 所以放大浏览器后，css 像素变少，物理像素不变，dpr 变大
+ lib-flexible
    - 动态改写 meta viewport 标签，缩放为 1 / dpr，即2倍屏放大两倍，3倍屏放大3倍
        * 如 scale = 1，设备宽度能容纳 375px；则 scale = 0.5 时，设备宽度能容纳 750px
    - html 标签添加 data-dpr 属性和 font-size 属性，并动态改写
        * font-size 为 width / 10 px
        * width / dpr < 540 直接用，大于540，width = 540 * dpr。也就是最大 540 * dpr
    - 初始屏幕宽度能容纳的 css 像素为设计分辨率的像素，实际物理像素为设计分辨率 * dpr；因为计算根元素 font-size 时乘了 dpr（用物理像素计算的 font-size），所以需要容纳的 css 像素也要变为 dpr 倍，即 scale = 1/dpr
    - postcss-pxtorem 中配置的设计分辨率如何起作用（以 750 为例）？
        * 总宽度永远是10rem。
        * 开发中写的 px 为设计稿中量出，根据所写的 px 和 750 的比例算出其转换为 rem 后的值。如宽度为 375px 的元素，转换后为 5rem。
        * 在真实设备查看时设备宽度仍是10rem，5rem的元素仍占宽度一半，实现适配。

```css
var width = docEl.getBoundingClientRect().width; // 获取到的是物理分辨率
if (width / dpr > 540) {
    width = 540 * dpr;
}
var rem = width / 10;
docEl.style.fontSize = rem + 'px';
```

    - 配合 postcss-pxtorem 使用，在 postcss.config.js 中做配置
+ vw 适配
    - 在 .postcssrc.js 中配置
    - 使用 postcss-px-to-viewport 做单位转换；判断关键字，兼容第三方 ui 库
    - cnjm-postcss-px-to-viewport

## Promise all race allSettled <font style="color:#DF2A3F;">----11</font>
+ Promise.all
    - 接收可迭代对象（Array，Map，Set），返回一个 Promise 实例
    - 返回值
        * 传入空的可迭代对象，同步返回  Promise fulfilled
        * 传入的数组不包含任何 Promise，异步 Promise fulfilled
        * 其他情况返回 Promise pending，都完成或有一个失败时异步的变为完成或失败
        * **总结：当且仅当传入的可迭代对象为空时同步（直接fulfilled），其他都是先 Pending，再变为 fulfilled/rejected**
    - 成功回调的参数是一个数组，按照参数顺序排列
    - 只要有一个失败，返回的 Promise 转为失败，错误信息为第一个失败的 reject
+ Promise.race
    - 返回一个 promise，一旦参数中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝
    - 如果参数是空的迭代，返回的 promise 永远是 pending
+ Promise.allSettled
    - 参数：promise 组成的可迭代对象
    - 返回一个 Promise实例，都完成时变为已解决
    - 成功回调参数是**对象数组，**每个结果对象都有 status（fulfilled/rejected），value（成功时有），reason（失败时有）
    - 如果传入的数组是空的，返回 fulfilled Promise

## encodeURIComponent()
## TCP 和 UDP
+ TCP
    - 面向连接（三次握手建立链接）
    - 可靠（序号，ACK确认，丢包重传）
    - 传输字节流（会将 HTTP 报文拆分拼接首部，成为 TCP 报文）
    - 有序（传输过程中可能会乱序，TCP 会重新排序）
    - 传输慢（需要建立连接，保证可靠性和有序性，比较耗时）
+ UDP
    - 不需要连接
    - 不可靠
    - 传输报文（没有拆分合并过程，物理链路限制最大 512字节）
    - 无序
    - 传输快（实时通信，语音通话，视频通话，DNS，视频流，广播电视，在线多媒体游戏）
    - DNS 实际上同时用 UDP 和 TCP [https://cloud.tencent.com/developer/article/1818152](https://cloud.tencent.com/developer/article/1818152)

## for (var i = 0; i < 7; i++)
```javascript
for (let i = 0; i < 7; i++) {
  setTimeout(() => {
    console.log(i)
  })
} // {} 里是一个 块，每一个 块 里有自己的 i；
// 用 var i 会提升，每次循环改同一个 i，打印出 7 个 7
```

## Content-type
+ 句法
    - Content-Type: text/html; charset=utf-8
    - Content-Type: multipart/form-data; boundary=something
+ 指令
    - media-type - MIME type
    - charset - 字符编码标准
    - boundary - 封装消息多个部分的边界
+ Media Types 完整列表[https://www.iana.org/assignments/media-types/media-types.xhtml](https://www.iana.org/assignments/media-types/media-types.xhtml)
+ 常用
    - text/plain
    - text/html
    - application/json
    - application/x-www-form-urlencoded ---post请求浏览器默认，参数格式 key=value&key=value
    - multipart/form-data ---不会对参数编码，常用于文件等二进制，使用 boundary ，相当于 &，让服务器知道如何拆分接收参数

## JSONP <font style="color:#DF2A3F;">----12</font>
+ 利用 script 标签没有跨域限制，创建 script 标签，src 指向请求地址，并提供一个回调函数，服务端将数据作为回调函数的参数返回（json 数据的包装，json padding），浏览器拿到响应后执行回调函数获取数据
+ 优点：简单易用，不需要服务端改动就可以实现跨域
+ 缺点：只能发送 get 请求；有安全风险

```html
<script src="http://domain/api?callback=jsonp"></script>
<script>
  function jsonp(data) {
    console.log(data)
  }
</script>
```

```javascript
function jsonp(url, data={}, cb='callback') {
  data.cb = cb
  const params = []
  for (let key in data) {
    params.push(`${key}=${data[key]}`)
  }
  const script = document.createElement('script')
  script.src = url + '?' + params.join('&')
  script.defer = true
  document.body.appendChild(script)
  return new Promise((resolve, reject) => {
    try {
      window[cb] = function (data) {
        resolve(data)
      }
    } catch (error) {
      reject(error)
    } finally {
      script.parentNode.removeChild(script)
    }
  })
}

// 使用
jsonp('http://xxx')
	.then(res => {
    console.log(res)
  })
```

+ [https://zh.javascript.info/script-async-defer](https://zh.javascript.info/script-async-defer)

## 判断是否数组 <font style="color:#DF2A3F;">----done</font>
+ Array.isArray()
+ instanceof 运算符：if (value instanceof Array) {}
    - a instanceof b === true，那么 a 的原型链上有 b.prototype，a 是 b 的实例或间接实例
    - Array.isarray() 也拒绝原型链中带有 Array.prototype，而实际不是数组的对象，但 instanceof Array 会接受
+ constructor 构造函数属性：arr.constructor === Array

## call apply bind
## JSON 语法
+ JavaScript Object Notation，是一种用于数据交换的文本格式
+ 格式
    - 复合类型的值只能是对象或数组，不能是函数、日期、正则
    - 原始类型的值只有四种：字符串，数值（十进制），布尔值，null（不能使用 undefined，NaN，Infinity）
    - 字符串必须使用双引号
    - 对象键名必须使用双引号
    - 数组或对象最后一个成员后面，不能加逗号
+ null、空数组、空对象都是合法的 JSON

## 浏览器事件循环
+ 浏览器需要处理用户操作、执行脚本、渲染、网络请求等
+ JS 是**单线程**的，且 JS 的主线程和渲染线程互斥。如果异步操作阻塞 JS 的执行，会造成浏览器的卡死。事件循环为浏览器引入了**任务队列**，使**异步任务可以非阻塞地进行**。
+ 浏览器事件循环在处理异步任务时不会一直等待其返回结果，而是将这个事件挂起，继续执行栈中的其他任务。当异步事件返回结果，将它放到任务队列中，但是不会立即执行回调，要等待当前执行栈中的任务都执行完毕，再取出任务队列中排在第一位的事件，将其对应的回调放到执行栈中执行。

## 居中
flex 水平垂直

```css
.parent {
  display: flex;
  justify-content: center;
  align-items: center;
}
```



absolute + transform 水平垂直

```css
.children {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```



块级元素内部的内联元素水平居中

```css
.parent {
  text-align: center;
}
```



块级元素居中

```css
.child {
  margin: 0 auto;
}
```



单行内联元素垂直居中：height = line-height

```css
height: 120px;
line-height: 120px;
```

## Three.js
+ 场景（Scene），渲染器（WebGLRenderer），循环渲染（requestAnimationFrame）
+ 相机
    - 透视摄像机 <font style="color:rgb(33, 148, 206);background-color:rgb(245, 245, 245);">PerspectiveCamera</font>
    - 正交摄像机 <font style="color:rgb(33, 148, 206);background-color:rgb(245, 245, 245);">OrthographicCamera</font>
+ 灯光
    - 环境光 AmbientLight：均匀照亮场景中所有物体
    - 平行光 DirectionalLight：平行光是沿着特定方向发射的光
    - 点光源 PointLight：从一个点向各个方向发射的光源。一个常见的例子是模拟一个灯泡发出的光。
    - 聚光灯 SpotLight：光线从一个点沿一个方向射出，随着光线照射的变远，光线圆锥体的尺寸也逐渐增大。
+ 加载器
    - 导入3D模型
    - ObjectLoader
    - GLTFLoader

## lk-node-todo
+ Commander.js 创建命令，处理命令行参数

```javascript
const { program } = require('commander');
program
    .command('add')
    .description('add a task')
    .action((source, destination) => {
      if(destination){
        let words = destination.join(' ')
        api.add(words)
      }else{
        console.log("error: missing required argument 'taskName'")
      }
    });
program.parse(process.argv);
```

+ Inquirer.js 实现命令行交互

```javascript
const inquirer = require('inquirer')
inquirer.prompt({
        type: 'list', name: 'action',
        message: '请选择操作',
        choices: [
            {name: '退出', value: 'quit'},
            {name: '已完成', value: 'markAsDone'},
            {name: '未完成', value: 'markAsUndone'},
            {name: '改标题', value: 'updateTitle'},
            {name: '删除', value: 'remove'}
        ]
    }).then(answer2 => {
        const action = actions[answer2.action]
        action && action(list, index)
    })
```

+ 创建 add，clear，list 三个命令
+ add：读文件，取命令行参数作为标题，加一条新内容，{ title: 'xx', done: false }，存文件
+ clear: 存空数组
+ list：读文件，列表及状态，操作每一条状态（完成，未完成，修改，删除），可添加
+ db.js 导出 read 和 write 方法，存 .todo 文件到 home 路径下作为数据库
+ 文件格式 [{ title: '待办1', done: false }, { title: '待办2', done: true }]

```javascript
program
  .command('hi')
  .description('hi you')
  .action(() => {
    inquirer
      .prompt({
        type: 'list',
        name: 'index',
        message: '请选择',
        choices: [
          { name: '啊1', value: '1' },
          { name: '啊2', value: '2' },
          { name: '啊3', value: '3' },
          { name: '啊4', value: '4' },
        ]
      }).then(answers => {
        console.log(answers)
      })
  })
program.parse()
```

+ node 读写文件，`fs.readFile()` `fs.writeFile()`

```javascript
fs.readFile(path, {flag: 'a+'}, (error, data) => {})
fs.writeFile(path, string, (error) => {})

read(path=dbPath){
  return new Promise((resolve, reject) => {
    fs.readFile(path, {flag: 'a+'}, (error, data)=>{
      if(error) return reject(error)
      let list
      try{
      }catch(error2){
        list = []
      }
      resolve(list)

    })
  })

},
write(list, path=dbPath){
  return new Promise((resolve, reject) => {
    const string = JSON.stringify(list)
    fs.writeFile(path, string, (error)=>{
      if(error) return reject(error)
      resolve()
    })
  })
}
```

## Canvas 画板
```javascript
var canvas = document.getElementById('canvas')
var ctx = canvas.getContext('2d')

// 路径
ctx.beginPath();
ctx.moveTo(75, 50);
ctx.lineTo(100, 75);
ctx.lineTo(100, 25);
ctx.fill();

// 矩形
ctx.fillRect(25, 25, 100, 100);
ctx.clearRect(45, 45, 60, 60);
ctx.strokeRect(50, 50, 50, 50);

// 弧
ctx.arc(75, 75, 50, 0, Math.PI * 2, true);
arc(x, y, radius, startAngle, endAngle, 顺时针)

ctx.fill();
ctx.stroke();

// 样式
ctx.fillStyle = "#FFA500";
ctx.strokeStyle = "rgba(255,0,0,0.5)";
// 渐变
var lineargradient = ctx.createLinearGradient(0,0,150,150);
var radialgradient = ctx.createRadialGradient(75,75,0,75,75,100);
// 图案
var ptrn = ctx.createPattern(img, 'repeat');
ctx.fillStyle = ptrn;

```

+ 实现：onmousedown 画圆点，onmousemove 连线，onmouseup 状态变量是否要画
+ 移动：ontouchstart 画圆点，ontouchmove 连线，ontouchend 状态变量
+ 橡皮：ctx.<font style="color:#DF2A3F;">clearRect</font>(x-5,y-5,10,10)
+ 清除：ctx.<font style="color:#DF2A3F;">clearRect</font>(0,0,yyy.width,yyy.height)
+ 保存：ctx.<font style="color:#DF2A3F;">toDataURL</font>('image/png')，将 canvas 元素转化成 base64 编码的 URL 字符串，生成 a 标签下载
+ 颜色：改 ctx.fillStyle 和 ctx.strokeStyle
+ 粗细：改画圆的半径和画线的宽度 ctx.lineWidth，半径是线宽的一半

## 斐波那契数列
+ 斐波那契数列是指：<font style="color:rgb(36, 41, 47);background-color:rgb(244, 246, 248);">第一项为0，第二项为1，从第三项开始，每一项都等于前两项之和</font>

```javascript
function fibonacci(n) {
  // 定义初始值
  var f0 = 0;
  var f1 = 1;
  var fn;

  // 如果输入 n 小于 2，直接返回对应的值
  if (n < 2) {
    return n;
  }

  // 从第三项开始循环计算每一项的值
  for (var i = 2; i <= n; i++) {
    fn = f0 + f1; // 当前项等于前两项之和
    f0 = f1; // 更新前一项的值
    f1 = fn; // 更新当前项的值
  }

  return fn; // 返回第 n 项的值
}
```

```javascript
// 用 Generator 和 for...of 循环实现斐波那契数列
function* fibonacci() {
  let [prev, curr] = [0, 1];
  for (;;) { // 无限循环语句，等价于 while(true){}
    yield curr;
    [prev, curr] = [curr, prev + curr];
  }
}

for (let n of fibonacci()) {
  if (n > 1000) break;
  console.log(n);
}
```



##  AST 抽象语法树 <font style="color:#DF2A3F;">----done</font>
+ 源代码编译过程中的一个中间表示形式，把源代码转为一个树形结构，每个节点是表达式、变量、操作符、函数，方便分析优化代码，检查错误，也可以把代码转换为其他形式的代码
+ PostCSS 就是把 css 转为 AST，之后由其他不同的插件处理
+ babel 把各种方言（TS，JSX）或新的语法特性转为 AST ，再由各种插件处理，再转回 js
+ Code → AST → 优化的 AST → Code

```javascript
x = 10 + 5 * (3 - 2)

// 生成的抽象语法树
 			 =
      / \
     x   +
        / \
       10  *
          / \
         5   -
            / \
           3   2
```

## 用过哪些库
+ lodash：节流防抖
+ dayjs：日期格式处理
+ zrender：绘图
+ 富文本
+ echarts
+ xlsx 解析 excel
+ three.js
+ Tweenjs 动画
+ 生成指纹
+ lib-flexible

## Vue 常见指令
+ v-if
+ v-show
+ v-on
+ v-bind
+ v-model
+ v-for
+ v-text 同文本插值
+ v-html
+ v-slot 具名插槽，缩写 #

## vue2 对数组处理，重写哪些方法
## flex 布局
+ 容器属性
    - flex-direction
    - flex-wrap
    - flex-flow
    - justify-content  主轴对齐方式
    - align-items  交叉轴对齐方式
    - align-content
+ 项目属性
    - order
    - flex-grow  项目的放大比例，默认0，即存在剩余空间也不放大
    - flex-shrink  项目的缩小比例，默认1，即空间不足项目缩小
    - flex-basis  分配多余空间前占的主轴空间，默认auto
    - flex  默认 `0 1 auto`
    - align-self

## 可选链操作符 ?.  空值合并操作符 ??
+ 可选链操作符
    - 访问可能不存在或为 null 或 undefined 的属性
    - 不存在立即返回 undefined

```javascript
// 不使用可选链操作符
if (obj && obj.property && obj.property.method) {
  obj.property.method();
}

// 使用可选链操作符
obj?.property?.method();
```

+ 空值合并操作符
    - 只有 null、undefined 被认为是 false
    - 0、空字符串、false

```javascript
// 使用逻辑或运算符
const result1 = value || defaultValue;

// 使用空值合并操作符 0、''、false 不会选择默认值， result2 === value
const result2 = value ?? defaultValue;
```

## 工程
+ 技术选型
    - 成熟稳定，文档齐全社区活跃，插件、生态丰富
    - 业务场景
        * 生命周期：长期核心项目，成熟稳定；边缘活动页可以用新技术，可以用jq快
        * 兼容性：web兼容浏览器，app兼容安卓ios
        * 团队成员：考虑成员技术栈，用约束性强的技术（ts），避免高度自由的ss
    - 易用性：易上手，好招人。尤其是中小城市
+ 代码规范：保证成员一致性，减少沟通成本，提高效率
    - 代码格式：缩进、分号、换行等。 Eslint
    - 命名
    - 注释
    - git规范，部署：拉分支，分支命名，提交，合并
+ 模块画，组件化
+ 构建工具
+ 异常监控

## 需要看
+ 如何定位内存泄漏
+ 浏览器事件循环
+ 谈谈CSS预处理器
+ 谈下 webpack loader 的机制（三）

